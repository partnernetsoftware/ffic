global()

"English \"String\""
"English String"
"中文字串"
print("English String")
print("中文字串")

@(assert(r),@?(r,print(r),exit("ko")))
assert(@T)

# logic version (slow)
@(fb(n),@?(lt(n,3),1,@+(fb(@-(n,1)),fb(@-(n,2)))))
assert(@=(55,fb(10)))

#tail version O(n)
@(fbi(a,b,count),@?(@==(count,0),b,fbi(@+(a,b),a,@-(count,1))))
#var(fib(n),fbi(1,0,n))
@(fib(n),fbi(1,0,n))
assert(@=(12586269025,fib(50)))


@(fbf(n), @(fbi(a,b,count),@?(@==(count,0),b,fbi(@+(a,b),a,@-(count,1)))), fbi(1,0,n))
fbf(30)
assert(@=(12586269025,fbf(50)))

@^()

# @->(count,
#     @-(1)
# )

@(var,@)
##         @(nil,@@)
##         @(true,@T)
##         @(false,@F)
##         @(if,@?)
##         @(add,@+)
##         @(sub,@-)
##         @(mul,@*)
##         @(div,@/)
##         #@(eq,@=)
##         @(cmp,@==)
##         @(same,@===)
##         @(vector,@V)
##         @(is_nil,@@?)

@(x,1)
assert(@=(1,x))

var(y,3)
assert(@=(3,y))

@@?(@F)
@==(@F,@@?(@F))
assert(@==(@F,@@?(@F)))

	@(++(n),@+(1,n))
++(3)
	assert(@==(
				4,++(3)
				))

#@(caar @L((a) car(car(a))))
#@(cadr @L((a) car(cdr(a))))
##  @(cadar @L(a() car(cdr(car(a)))))
#@(cdar @L(a() cdr(car(a))))
#@(cddr @L(a() cdr(cdr(a))))
#@(caddr @L(a() car(cdr(cdr(a)))))
#@(cdddr @L(a() cdr(cdr(cdr(a)))))
#@(cdadr @L(a() cdr(car(cdr(a)))))
#@(cadddr @L(a() car(cdr(cdr(cdr(a))))))

@(caar(a),car(car(a)))
@(cadr(a),car(cdr(a)))
@(cdar(a),cdr(car(a)))
@(cddr(a),cdr(cdr(a)))
@(cadar(a),car(cdr(car(a))))
#@(cadar(a),car(cdar(a))))
@(caddr(a),car(cdr(cdr(a))))
@(cdddr(a),cdr(cdr(cdr(a))))
@(cdadr(a),cdr(car(cdr(a))))
@(cdddr(a),car(cdr(cdr(cdr(a)))))


caar(((1,2),3))
assert(@=(1,caar(((1,2),3))))
cadr((1,2,3))
assert(@=(2,cadr((1,2,3))))

cdar(((1,2),3))
cadar(((1,2),3))
assert(@=(
2,cadar(((1,2),3))
))

@(sum_of_squares(num_list),
		@(sos_helper(remaining,sum_so_far),@?(@@?(remaining),sum_so_far,sos_helper(cdr(remaining),@+(sum_so_far,@*(car(remaining),car(remaining))))))
		sos_helper(num_list 0))

sum_of_squares(list(2 3 4) )           # 4+9+16=29

assert(@=(29,
sum_of_squares(list(2 3 4) )
))

sum_of_squares(^(1,2,3,4))
assert(@=(30,
sum_of_squares(^(1,2,3,4))
))

sum_of_squares((1,2,3,4))
assert(@=(30,
sum_of_squares((1,2,3,4))
))

# macros
#  @(procedure_body @L((proc) caddr(proc)))
#@(procedure_args @L(proc() cadr(proc)))
#@(mutate_procedure_env(name new_env) setcar(cdddr(name) new_env))
#@(mutate_procedure_body(name new_body) setcar(cddr(name) list(new_body)))
#@(mutate_procedure_args(name new_args) setcar(cdr(name) new_args))

@(new_env(),cons(cons(^() ^()) ^()))

@(procedure_body(proc),caddr(proc))
@(procedure_args(proc),cadr(proc))
@(mutate_procedure_ctx(name new_env),setcar(cdddr(name),new_env))
@(mutate_procedure_body(name,new_body),setcar(cddr(name),list(new_body)))
@(mutate_procedure_args(name,new_args),setcar(cdr(name) new_args))

@(construct_procedure(args body ctx)
  let((new_proc(cons(@P,cons(^(),cons(^(),cons(^()))))))
    mutate_procedure_args(new_proc args)
    mutate_procedure_body(new_proc body)
    mutate_procedure_ctx(new_proc ctx)
    new_proc))

# @(if_zero(x,then),list(if list(@= x 0) then))
@(if_zero(x,then),^@?((@= x 0) then))

construct_procedure(^a() ^cons(a 10) ^global())

@(new_func,construct_procedure(^(a) ^cons(a 10) ^global()))

new_func(5)

exit()

# Construct a procedure with macro
@(new_func,construct_procedure(^a() ^cons(a 10) global()))
print(new_func)

exit()

@(with_macros,construct_procedure(^x() if_zero(^x ^ZERO) global()))

with_macros()
list(2 3 4)

c_int("12345")

exit()

@(gen_accum(number)
  @L(amount()
    set(number @+(number amount))
    number))

# Everytime new_accum() is called, it's accumulator should be increased by one
@(new_accum gen_accum(0))

# Simple loop
@(for @L(start(end do)
    @(for_loop(a z)
      @?(@=(a z)
        ^Done;; Last iteration
        begin(
          do()
          for_loop(@+(1 a) z))))
    for_loop(start end do)))

@(make_withdraw(balance)
  @L(amount()
    @?(gt(balance amount)
      begin(set(balance @-(balance amount))
        balance)
      "Insufficient funds")))

exit("OK")
